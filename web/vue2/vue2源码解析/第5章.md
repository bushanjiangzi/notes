## 计算属性 vs 侦听属性

**computed watch**

- 依赖收集: new Watcher() 依赖到 this.subs.push(sub)

- 派发更新: dep.notify()

- 计算属性的本质是 computed watcher

- 侦听属性的本质是 user watcher,它支持 deep、aync、immediate 等配置

- 计算属性适合在模板渲染中，某个值是依赖了其他的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某一个值的变化去完成一段复杂的业务逻辑

## 组件更新

- 组件更新的过程核心就是新旧 vnode diff,对新旧节点相同以及不同的情况分别做不同的处理

- 新旧节点不同的更新流程是创建新节点->更新父占位符节点->删除旧节点

- 新旧节点相同的更新流程是去获取它们的 children，根据不同情况做不同的更新逻辑

## Props

- 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。

- 每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。但不应该在一个子组件内部改变 prop。
