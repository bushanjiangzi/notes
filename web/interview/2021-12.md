### 硅基仿生

- css 盒子模型

  从里到外依次为 content、padding、padding 和 margin；box-sizing：content-box，border-box；

  content-box 是默认值。如果你设置一个元素的宽为 100px，那么这个元素的内容区会有 100px 宽，

  border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在 width 内的。

- position 属性，absolute 定位的元素内有没遇到什么问题

  1. absolute - 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。

  2. fixed - 生成绝对定位的元素，相对于浏览器窗口进行定位。

  3. relative - 生成相对定位的元素，相对于其正常位置进行定位。

  4. static - 默认值。没有定位，元素出现在正常的流中

- 水平垂直居中

  > position 定位（适用于子盒子有宽度和高度的时候）

  > position+transform（子盒子有或没有宽高的时候都适用）

  > flex 布局（子盒子有或没有宽高的时候都适用)

- 画三角形

  ```
    border-style: solid;
    border-width: 100px 100px 100px 100px;
    border-color: transparent transparent blue transparent;
    width: 0px;
    height: 0px;
  ```

- margin 重叠如何计算

  水平边距永远不会重合，2 个或以上的块级盒模型相邻的垂直 margin 会重叠。最终的 margin 值计算方法如下（正正取最大值，正负相加，负负取最负值）

  1. 全部都为正值，取最大者；

  2. 不全是正值，就从正相邻 margin 的最大值中减去负相邻 margin 的绝对值的最大值；

  3. 没有正值，则都取绝对值，然后用 0 减去最大值。

- flex 和 griad 布局区别

  1. 它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局

  2. griad 布局实现九宫格

  ```
    <html>
      <head>
        <style type="text/css">
          .content {
            padding: 10;
            display: grid;
            grid-template-columns: auto auto auto;
            grid-template-rows: auto auto auto;
            height: 780px;   //padding 有个20的宽度
            background-color: #000;
            grid-gap: 10px;
          }
          .b {
            background-color: yellow;
          }
        </style>
      </head>
      <body>
        <div class="content">
          <div class="b">1</div>
          <div class="b">2</div>
          <div class="b">3</div>
          <div class="b">4</div>
          <div class="b">5</div>
          <div class="b">6</div>
          <div class="b">7</div>
          <div class="b">8</div>
          <div class="b">9</div>
        </div>
      </body>
    </html>
  ```

- js 原始数据类型，基本数据类型和引用数据类型区别，es6 新增了哪些

  1. 基本数据类型 Undefined、Null、Number、String、Boolean、Symbol（es6）、BigInt（新增）

  2. 引用数据类型 Object 、Array 、Function 、Data

  3. 区别：基本数据类型存在于栈中，而引用数据类型是保存在堆内存中的对象中无法直接访问，只能通过操作对象在栈中的内存地址去调用

- 深拷贝实现方式，JSON.parse，JSON.stringfy 的缺陷（null 值会如何）

  JSON.parse(JSON.stringify(obj))就是利用 JSON.stringify 将 js 对象序列化（JSON 字符串），再使用 JSON.parse 来反序列化（还原）js 对象；序列化的作用是存储和传输。不过，这种实现深拷贝的方法有局限性，它只适用于一般数据的拷贝（对象、数组）

  1. 如果 json 里面有时间对象，则序列化结果：时间对象=>字符串的形式；

  2. 如果 json 里有 RegExp、Error 对象，则序列化的结果将只得到空对象 RegExp、Error => {}；

  3. 如果 json 里有 function,undefined，则序列化的结果会把 function,undefined 丢失；

  4. 如果 json 里有 NaN、Infinity 和-Infinity，则序列化的结果会变成 null；

  5. 如果 json 里有对象是由构造函数生成的，则序列化的结果会丢弃对象的 constructor；

  6. 如果对象中存在循环引用的情况也无法实现深拷贝

  解决方法：JSON.stringify(info, (key, value) => typeof value === 'undefined' ? '' : value)

- 谈谈原型链的理解

  1. 每个函数都有 prototype 属性，该属性指向原型对象；使用原型对象的好处是所有对象实例共享它所包含的属性和方法。

  2. 每个对象都拥有一个原型对象，通过**proto** 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null。

- let，const 和 var 区别，函数存在变量提升吗

  1. var 声明变量存在变量提升，let 和 const 不存在变量提升;

  2. let、const 都是块级局部变量;

  3. 同一作用域下 let 和 const 不能声明同名变量，而 var 可以

  4. js 中创建函数有两种方式：函数声明式和函数字面量式。只有函数声明才存在函数提升！

  ```
  console.log(f1); // function f1() {}
  console.log(f2); // undefined
  function f1() {}
  var f2 = function() {}
  ```

- es6 新增的语法，用过哪些

  1. 新的变量声明方式 let,const

  2. 解析结构:const [a, b] = arr; const {name, age} = obj

  3. 模板字符串:console.log(`Hello ${name}, how are you ${time}?`);

  4. 默认参数：

  ```
    function greet(name = 'Student', greeting = 'Welcome') {
      console.log(`${Greeting} ${Name}!`);
    }
  ```

  5. 展开运算符:const arr = [...arr1,...arr2]; const obj = {...obj1, obj2 }

  6. 箭头函数:箭头函数没有自己的 this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。如果上下文没有 this, 则 this 指向 Window 对象。

  7. 对象字面量简写法:const gemstone = {type,color,carat};

  8. Class 类

  9. promise 和 async/awit

  10. Set 和 Map

- 箭头函数和普通函数的区别

  1. 箭头函数不会创建自己的 this，所以它没有自己的 this，它只会从自己的作用域链的上一层继承 this;

  2. 箭头函数继承而来的 this 指向永远不变;

  3. .call()/.apply()/.bind()无法改变箭头函数中 this 的指向;

  4. 箭头函数不能作为构造函数使用;

  5. 箭头函数没有自己的 arguments;

  6. 箭头函数没有原型 prototype;

  7. 箭头函数不能用作 Generator 函数，不能使用 yeild 关键字。

- 0.1+0.2=0.3 吗？为何会有精度丢失问题

  在计算机中将浮点数转为二进制数：整数部分采用除 2 取余法，小数部分采用乘 2 取整法；

  计算机的二进制实现和位数限制有些数无法有限表示，只能模仿十进制进行四舍五入了，但是二进制只有 0 和 1 两个，于是变为 0 舍 1 入。这即是计算机中部分浮点数运算时出现误差，丢失精度的根本原因。大整数的精度丢失和浮点数本质上是一样的，尾数位最大是 52 位，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）。

- for in，for of 循环的区别

  1. for...in 循环：只能获得对象的键名，不能获得键值; for...of 循环：允许遍历获得键值

  2. 对于普通对象，没有部署原生的 iterator 接口，直接使用 for...of 会报错

  3. for...in 循环不仅遍历数字键名，还会遍历手动添加的其它键，甚至包括原型链上的键。for...of 则不会这样

  4. forEach 循环无法中途跳出，break 命令或 return 命令都不能奏效, for...of 循环可以与 break、continue 和 return 配合使用，跳出循环

  5. 无论是 for...in 还是 for...of 都不能遍历出 Symbol 类型的值，遍历 Symbol 类型的值需要用 Object.getOwnPropertySymbols() 方法

  总之，for...in 循环主要是为了遍历对象而生，不适用于遍历数组，for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象

- 获取对象属性，通过点和[]的区别是什么

  1. 点操作符: 静态的。右侧必须是一个以属性名称命名的简单标识符。属性名用一个标识符来表示。标识符必须直接出现在 js 程序中，它们不是数据类型，因此程序无法修改它们。

  2. 中括号操作符: 动态的。方括号里必须是一个计算结果为字符串的表达式，属性名通过字符串表示。字符串是 js 的数据类型，在程序运行时可以修改和创建它们。

  区别：

  1. []中括号法：可以用变量作为属性名或访问，而点语法不可以;

  2. []中括号法：可以用数字作为属性名，而点语法不可以;

  3. []中括号法：可以动态访问的属性名，可以在程序运行时创建和修改属性，点操作符就不行；

  4. 如果属性名中包含会导致语法错误的字符，或者属性名是关键字或者保留字，也可以使用方括号表示法；

  5. 简单利用：在数组原型链上增加一个去重得的方法，并能实现链式写法。

- i++和++i 的区别

  i++是先赋值，再加一；++i 是先加一，再赋值。

  ```
    let i = 0;
    let j = i++;
    console.log(`i=${i},j=${j}`); // i=1,j=0
    let x = 0;
    let y = ++x;
    console.log(`x=${x},y=${y}`); // x=1,y=1
  ```

  ++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的

- v-show 和 v-if 的区别

  1. 相同点：v-if 与 v-show 都可以动态控制 dom 元素显示隐藏；

  2. 不同点：v-if 显示隐藏是将 dom 元素整个添加或删除，而 v-show 隐藏则是为该元素添加 css--display:none，dom 元素还在。

- 组件传参方式，vuex 的状态有哪些

  1. Props；$emit；bus；Vuex；$parent；$children；ref：this.$refs.child.childMethod()

  2. vuex 的状态：State , Getter , Mutation , Action , Module

- keep-alive 用法

  当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。

  ```
  <!-- 失活的组件将会被缓存！-->
  <keep-alive>
    <component v-bind:is="currentTabComponent"></component>
  </keep-alive>
  ```

- vue-router 两种模式有何区别

  1. hash 模式：vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。

  2. 因为 HTML5 标准发布，多了两个 API，pushState() 和 replaceState()。通过这两个 API （1）可以改变 url 地址且不会发送请求，（2）不仅可以读取历史记录栈，还可以对浏览器历史记录栈进行修改。除此之外，还有 popState().当浏览器跳转到新的状态时，将触发 popState 事件.

- vue2 和 vue3 区别

  1. https://www.jianshu.com/p/83758d08a1c8

- vue 中 data 为什么定义为方法而不是对象

  1. vue 实例的时候定义 data 属性既可以是一个对象，也可以是一个函数；组件中定义 data 属性，只能是一个函数；

  2. 实例对象 data 可以是对象也可以是函数（根实例是单例），不会产生数据污染情况；

  3. 组件实例对象 data 必须为函数，目的是为了防止多个组件实例对象之间共用一个 data，产生数据污染。采用函数的形式，initData 时会将其作为工厂函数都会返回全新 data 对象。

- vue.set()用在什么情况下，响应式监听缺陷是技术问题还是什么

  1. 由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。

  2. 对于对象：Vue 无法检测 property 的添加或移除；

  3. 对于数组：当你利用索引直接设置一个数组项时；当你修改数组的长度时。

- this.nextTick()的原理是什么？

  > 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM

  [Vue：this.$nextTick 的原理和用途](https://juejin.cn/post/6844903911141146631)

  vue 异步更新的原理：

  1. 修改 Vue 中的 Data 时，就会触发所有和这个 Data 相关的 Watcher 进行更新。

  2. 首先，会将所有的 Watcher 加入队列 Queue。

  3. 然后，调用 nextTick 方法，执行异步任务。

  4. 在异步任务的回调中，对 Queue 中的 Watcher 进行排序，然后执行对应的 DOM 更新。

- 跨域问题

  同源策略指的是：协议+域名+端口三者皆相同，可以视为在同一个域，否则为不同域。同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。作用是一个用于隔离潜在恶意文件的重要安全机制。所限制的跨域交互包括：Cookie、LocalStorage、IndexdDB 等存储内容；DOM 节点；Ajax 请求。

  解决方法：
  
  1. jsonp：只支持 GET，不支持 POST 请求，不安全 XSS
  
  2. cors：需要后台配合进行相关的设置
  
  3. postMessage：配合使用 iframe，需要兼容 IE6、7、8、9
  
  4. document.domain：仅限于同一域名下的子域
  
  5. websocket：需要后台配合修改协议，不兼容，需要使用 http://socket.io
  
  6. proxy：使用代理去避开跨域请求，需要修改 nginx、apache 等的配置

- SEO 优化

  搜索对着三项的权重逐个减小，title值强调重点即可；description把页面内容高度概括，不可过分堆砌关键词；keywords列举出重要关键词。

  1. <title>网站标题</title>

  2. <meta name=”Description” Content=”你网页的简述”>

  3. <meta name=”Keywords” Content=”关键词1,关键词2,关键词3,关键词4″>

  4. 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页，如：header 、section、footer、h1-h6和nav等

- 性能优化问题，iconfont 和图片的区别，原理是什么

  1. 请减少HTTP请求基本原理;

  2. 减少Repaint 和 Reflow；

  3. 请减少对DOM的操作；

  4. 使用JSON格式来进行数据交换；

  5. 高效使用HTML标签和CSS样式；

  6. 使用CDN加速（内容分发网络）；

  7. 精简CSS和JS文件；

  8. 压缩图片和使用图片Sprite技术；

  9. 注意控制Cookie大小和污染。

  在电脑上，我给电脑规定 a 的样子是个 三角形，那么当显示 a 的时候，他就显示个三角形。当我把网页上的所有图标都对应一个字符的时候，你在代码里输入某个字符，那这个字符就显示你规定的形状，这就是 iconfont 图标。

- webpack 配置有哪些
  ```
    module.exports = {
      cache: true, // 开启缓存功能，这样只有变化的文件才会重新加载，可提升构建速度
      entry: {},
      output: {},
      module: {},
      resolve: {},
      externals: {},
      plugins: {},
      devServer: {}, // 
    }
  ```

- 浏览器渲染机制，文件加载先后顺序

  1. [浏览器加载解析渲染机制的全面解析](https://www.jianshu.com/p/e8f858f9605a)；

  2. 主流程：解析html以构建dom树->构建render树->布局render树->绘制render树；

  3. 未引入js：![](https://upload-images.jianshu.io/upload_images/4761597-edbd38703fc09ba8.png?imageMogr2/auto-orient/strip|imageView2/2/w/624/format/webp)

  4. 引入js：![](https://upload-images.jianshu.io/upload_images/4761597-4657c3311915fd81.png?imageMogr2/auto-orient/strip|imageView2/2/w/791/format/webp)

  5. 为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render tree。它是解析完一部分内容就显示一部分内容，
  同时，可能还在通过网络下载其余内容。

  6. css解析：在html解析的过程中，遇到style标签会直接解析，而遇到link标签会去加载样式表。Firefox在存在样式表还在加载和解析时阻塞所有的脚本，
  而chrome只在当脚本试图访问某些可能被未加载的样式表所影响的特定的样式属性时才阻塞这些脚本。

  7. html，css，js的阻塞问题分析：

    css如果在js之前，会阻塞js的执行，从而阻塞DOM tree构建
    
    要想不阻塞DOM tree构建，需要将js在body底部或者使用defer

    html解析的过程中遇到script时，如果是嵌入脚本，会执行并阻塞dom tree构建；如果是外链JS脚本，则会进行加载后执行，并阻塞dom tree构建。但不管怎样，
    由于浏览器的预解析优化，会新开一个线程加载后续资源。并且，为了确保js能拿到最新的DOM元素信息 CSSOM信息，js执行前会等待css加载完毕并渲染页面。

- 垃圾回收机制

  JS执行环境中的垃圾回收器怎样才能检测哪块内存可以被回收有两种方式：标记清除（mark and sweep）、引用计数(reference counting)

  1. 标记清除（mark and sweep）：大部分浏览器以此方式进行垃圾回收，当变量进入执行环境（函数中声明变量）的时候，垃圾回收器将其
  标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”，在离开环境之后还有的变量则是需要被删除的变量。
  标记方式不定，可以是某个特殊位的反转或维护一个列表等。

  2. 引用计数：这种方式常常会引起内存泄漏，低版本的IE使用这种方式。机制就是跟踪一个值的引用次数，当声明一个变量并将一个引用类型
  赋值给该变量时该值引用次数加1，当这个变量指向其他一个时该值的引用次数便减一。当该值引用次数为0时就会被回收。

- promise，setTimeout 和 setInterval 区别，setTimeout 设置一秒会在一秒后执行吗

  **事件循环**

  JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，Event Loop 的方案应用而生。Event Loop 包含两类：一类是基于 Browsing Context，一种是基于 Worker。二者的运行是独立的，也就是说，每一个 JavaScript 运行的"线程环境"都有一个独立的 Event Loop，每一个 Web Worker 也有一个独立的 Event Loop。

  **任务队列**
  根据规范，事件循环是通过任务队列的机制来进行协调的。一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。

  **宏任务**
  (macro)task，可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。浏览器为了能够使得JS内部(macro)task与DOM任务能够有序的执行，会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染。宏任务包含：
  ```
    script(整体代码)
    setTimeout
    setInterval
    I/O
    UI交互事件
    postMessage
    MessageChannel
    setImmediate(Node.js 环境)
  ```

  **微任务**
  microtask,可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。microtask,可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。包含：
  ```
    Promise.then
    Object.observe
    MutationObserver
    process.nextTick(Node.js 环境)
  ```

  **运行机制**
  在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：

    1. 执行一个宏任务（栈中没有就从事件队列中获取）
    
    2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
    
    3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
    
    4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
    
    5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）
  
  **例子**
  (js 宏任务和微任务)[https://www.cnblogs.com/ckAng/p/11133643.html]
  ```
    setTimeout(() => {
      //执行后 回调一个宏事件
      console.log('内层宏事件3')
    }, 0)
    console.log('外层宏事件1');

    new Promise((resolve) => {
        console.log('外层宏事件2');
        resolve()
    }).then(() => {
        console.log('微事件1');
    }).then(()=>{
        console.log('微事件2')
    })
    // 打印
    // 外层宏事件1
    // 外层宏事件2
    // 微事件1
    // 微事件2
    // 内层宏事件3
  ```

- 小程序登录流程

  1. 调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。
  
  2. 调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 、 用户在微信开放平台帐号下的唯一标识UnionID（若当前小程序已绑定到微信开放平台帐号）
  和 会话密钥 session_key。会话密钥 session_key 是对用户数据进行 加密签名 的密钥。临时登录凭证 code 只能使用一次。

- 移动端 1px 问题

  由于不同的手机有不同的像素密度导致的。如果移动显示屏的分辨率始终是普通屏幕的2倍，1px的边框在devicePixelRatio=2的移动显示屏下会显示成2px，所以在高清瓶下看着1px总是感觉变胖了；

  解决方法：

  1. 在ios8+中当devicePixelRatio=2的时候使用0.5px
  ```
    p {
      border:1px solid #000;
    }
    @media (-webkit-min-device-pixel-ratio: 2) {
      p {
         border:0.5px solid #000;
       }
    }
  ```
  2. 伪元素 + transform 实现

  3. viewport + rem 实现

    这种兼容方案相对比较完美，适合新的项目，老的项目修改成本过大。
  
  4. 使用box-shadow模拟边框
    
    利用css 对阴影处理的方式实现0.5px的效果
    ```
      .box-shadow-1px {
        box-shadow: inset 0px -1px 1px -1px #c8c7cc;
      }
    ```

- 谈谈对 electron 的理解，electron 渲染进程和主进程关系，windows 对象和 web 的有什么区别

  1. Electron是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入 Chromium 和 Node.js 到 二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux。

  1. electron核心我们可以分成2个部分，主进程和渲染进程。主进程连接着操作系统和渲染进程，可以把她看做页面和计算机沟通的桥梁。渲染进程就是我们所熟悉前端环境了。只是载体改变了，从浏览器变成了window。传统的web环境我们是不能对用户的系统就行操作的。而electron相当于node环境，我们可以在项目里使用所有的node api 。

  3. 主进程：以往的web页面都是运行在浏览器的沙箱中，由于沙箱机制，就无法访问本地操作系统资源，这是浏览器的一种安全机制。那如果要开发桌面应用，不能访问本地资源，那肯定是不行的。Electron将Node.js融合进来，让node.js作为整个程序的管家，并且可以访问本地资源，同时这个管家也管理着整个程序的生命周期，以及渲染进程窗口的创建与销毁。 这个管家就是主进程。

  4. 渲染进程：Electron同时也融合了Chromium来展示界面，借用了Chromium的多进程的架构，在Chromium中一个页面就是一个渲染进程，每一个页面都是互不影响的，避免了一个页面的崩溃导致全部页面的无法使用。在Electron每一个新建的窗口就是一个渲染进程，同样也是独立的。

  5. 进程通信：在Electron的渲染进程中，像dialog、menu模块是不能使用的，只能在主进程中使用。要想在渲染进程中使用，就要进行主、渲染进程之间通信。ipcMain与ipcRenderer，通过这两个模块可以实现进程之间的通信。

    - ipcMain 在主进程中使用，用来处理渲染进程发送的消息

    - ipcRenderer 在渲染进程中使用，用来发送信息给主进程或者接受主进程发来的消息
    ```
      // 主进程
      const {ipcMain} = require('electron')
      // 监听渲染程序发来的事件
      ipcMain.on('something', (event, data) => {
          event.sender.send('something1', '我是主进程返回的值')
      })

      // 渲染进程
      const { ipcRenderer} = require('electron') 
      // 发送事件给主进程
      ipcRenderer.send('something', '传输给主进程的值')  
      // 监听主进程发来的事件
      ipcRenderer.on('something1', (event, data) => {
          console.log(data) // 我是主进程返回的值
      })
    ```
  
  6. remote模块

    使用 remote 模块，可以调用main 进程对象的方法，而不需要显示发送 进程间的消息。

    ```
      const { dialog } = require('electron').remote
      dialog.showMessageBox({type: 'info', message: '在渲染进程中直接使用主进程的模块'})
    ```
  7. webContents

    webContents负责主进程向渲染进程发消息。 它是BrowserWindow对象的一个属性。
    ```
      const {app, BrowserWindow} = require('electron')
      let win
      app.on('ready', () => {
        win = new BrowserWindow({width: 800, height: 600})
        // 加载页面
        win.loadURL('./index.html')
        // 导航完成时触发，即选项卡的旋转器将停止旋转，并指派onload事件后。
        win.webContents.on('did-finish-load', () => {
          // 发送数据给渲染程序
          win.webContents.send('something', '主进程发送到渲染进程的数据')
        })
      })
    ```

- 进程和线程区别

  进程是资源分配的最小单位，线程是CPU调度的最小单位；做个简单的比喻：进程=火车，线程=车厢。

  1. 线程在进程下行进（单纯的车厢无法运行）
  
  2. 一个进程可以包含多个线程（一辆火车可以有多个车厢）
  
  3. 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
  
  4. 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
  
  5. 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
  
  6. 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
  
  7. 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
  
  8. 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
  
  9. 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

- 谈谈对微前端的理解

  [微前端到底是什么？](https://zhuanlan.zhihu.com/p/96464401)

  即，一种由独立交付的多个前端应用组成整体的架构风格。具体的，将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的小块，而在用户看来仍然是内聚的单个产品。

  **优势**

  1. 代码库更小，更内聚、可维护性更高
  
  2. 松耦合、自治的团队可扩展性更好
  
  3. 渐进地升级、更新甚至重写部分前端功能成为了可能

  **集成方式**
  
  1. 服务端集成：如 SSR 拼装模板
  
  2. 构建时集成：如 Code Splitting
  
  3. 运行时集成：如通过 iframe、JS(前端路由)、Web Components 等方式

- 大文件上传如何处理

  [前端大文件切片上传](https://juejin.cn/post/7053658552472174605)

  [JS大文件上传解决方案](https://www.cnblogs.com/songsu/p/11527655.html)

  [filereader api on big files](https://stackoverflow.com/questions/25810051/filereader-api-on-big-files)

- http 请求有哪些，它们之间区别是什么

  1. GET：从服务器获取数据（给的少拿的多）
  
  2. POST：向服务器推送数据（给的多拿的少）
  
  3. DELETE：删除服务器的一些内容
  
  4. PUT：向服务器存放一些内容
  
  5. HEAD:只请求页面的头部
  
  6. TRACE（或OPTIONS）：发送一个探测性请求，如果返回了信息说明建立了连接

  **GET VS POST**
  1. 传参方式：GET：基于URL地址“问号传参”，POST基于“请求主体”把信息传给服务器。（GET一般用于拿，POST一般用于推送内容）

  2. GET不安全，POST相对安全（记住是相对），因为GET是基于“问号传参”把信息传递给服务器，容易被骇客进行URL劫持。POST是基于请求主体传递的，相对来说不好被劫持。
  所以涉及到登录注册等信息应使用POST。

  3. GET会产生不可控制的缓存，POST不会，GET请求产生缓存的原因：连续多次向相同的地址（传递的参数也是一致的）发送请求，浏览器会把之前获取的数据从缓存中拿到，
  导致无法从服务器获取最新的数据（POST不会）。解决get请求缓存方式：在末尾添加一个随机数使每次请求的地址都不一致，比如时间戳。
