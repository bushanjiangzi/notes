### 硅基仿生

- css 盒子模型

  从里到外依次为 content、padding、padding 和 margin；box-sizing：content-box，border-box；

  content-box 是默认值。如果你设置一个元素的宽为 100px，那么这个元素的内容区会有 100px 宽，

  border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在 width 内的。

- position 属性，absolute 定位的元素内有没遇到什么问题

  1. absolute - 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。

  2. fixed - 生成绝对定位的元素，相对于浏览器窗口进行定位。

  3. relative - 生成相对定位的元素，相对于其正常位置进行定位。

  4. static - 默认值。没有定位，元素出现在正常的流中

- 水平垂直居中

  > position 定位（适用于子盒子有宽度和高度的时候）

  > position+transform（子盒子有或没有宽高的时候都适用）

  > flex 布局（子盒子有或没有宽高的时候都适用)

- 画三角形

  ```
    border-style: solid;
    border-width: 100px 100px 100px 100px;
    border-color: transparent transparent blue transparent;
    width: 0px;
    height: 0px;
  ```

- margin 重叠如何计算

  水平边距永远不会重合，2个或以上的块级盒模型相邻的垂直margin会重叠。最终的margin值计算方法如下（正正取最大值，正负相加，负负取最负值）

  1. 全部都为正值，取最大者；

  2. 不全是正值，就从正相邻margin的最大值中减去负相邻margin的绝对值的最大值；

  3. 没有正值，则都取绝对值，然后用0减去最大值。

- flex 和 griad 布局区别

  1. 它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局

  2. griad布局实现九宫格

  ```
    <html>
      <head>
        <style type="text/css">
          .content {
            padding: 10;
            display: grid;
            grid-template-columns: auto auto auto;
            grid-template-rows: auto auto auto;
            height: 780px;   //padding 有个20的宽度
            background-color: #000;
            grid-gap: 10px;
          }
          .b {
            background-color: yellow;
          }
        </style>
      </head>
      <body>
        <div class="content">
          <div class="b">1</div>
          <div class="b">2</div>
          <div class="b">3</div>
          <div class="b">4</div>
          <div class="b">5</div>
          <div class="b">6</div>
          <div class="b">7</div>
          <div class="b">8</div>
          <div class="b">9</div>
        </div>
      </body>
    </html>
  ```

- js 原始数据类型，基本数据类型和引用数据类型区别，es6 新增了哪些
  
  1. 基本数据类型 Undefined、Null、Number、String、Boolean、Symbol（es6）、BigInt（新增）
  
  2. 引用数据类型 Object 、Array 、Function 、Data

  3. 区别：基本数据类型存在于栈中，而引用数据类型是保存在堆内存中的对象中无法直接访问，只能通过操作对象在栈中的内存地址去调用

- 深拷贝实现方式，JSON.parse，JSON.stringfy 的缺陷（null 值会如何）

  JSON.parse(JSON.stringify(obj))就是利用 JSON.stringify 将 js 对象序列化（JSON 字符串），再使用 JSON.parse 来反序列化（还原）js 对象；序列化的作用是存储和传输。不过，这种实现深拷贝的方法有局限性，它只适用于一般数据的拷贝（对象、数组）

  1. 如果 json 里面有时间对象，则序列化结果：时间对象=>字符串的形式；

  2. 如果 json 里有 RegExp、Error 对象，则序列化的结果将只得到空对象 RegExp、Error => {}；

  3. 如果 json 里有 function,undefined，则序列化的结果会把 function,undefined 丢失；

  4. 如果 json 里有 NaN、Infinity 和-Infinity，则序列化的结果会变成 null；

  5. 如果 json 里有对象是由构造函数生成的，则序列化的结果会丢弃对象的 constructor；

  6. 如果对象中存在循环引用的情况也无法实现深拷贝

- 谈谈原型链的理解

  1. 每个函数都有 prototype 属性，该属性指向原型对象；使用原型对象的好处是所有对象实例共享它所包含的属性和方法。

  2. 每个对象都拥有一个原型对象，通过__proto__ 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null。


- let，const 和 var 区别，函数存在变量提升吗

  1. var声明变量存在变量提升，let和const不存在变量提升;

  2. let、const都是块级局部变量;

  3. 同一作用域下let和const不能声明同名变量，而var可以

  4. js中创建函数有两种方式：函数声明式和函数字面量式。只有函数声明才存在函数提升！

  ```
  console.log(f1); // function f1() {}   
  console.log(f2); // undefined  
  function f1() {}
  var f2 = function() {}
  ```

- es6 新增的语法，用过哪些

  1. 新的变量声明方式let,const

  2. 解析结构:const [a, b] = arr; const {name, age} = obj

  3. 模板字符串:console.log(`Hello ${name}, how are you ${time}?`);

  4. 默认参数：
  ```
    function greet(name = 'Student', greeting = 'Welcome') {
      console.log(`${Greeting} ${Name}!`);
    }
  ```
  5. 展开运算符:const arr = [...arr1,...arr2]; const obj = {...obj1, obj2 }

  6. 箭头函数:箭头函数没有自己的this。箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值。如果上下文没有this, 则this指向Window对象。

  7. 对象字面量简写法:const gemstone = {type,color,carat};

  8. Class类

  9. promise和async/awit

  9. Set和Map

- 箭头函数和普通函数的区别

- 0.1+0.2 = 0.3 吗？为何会有精度丢失问题

  在计算机中将浮点数转为二进制数：整数部分采用除2取余法，小数部分采用乘2取整法；

  计算机的二进制实现和位数限制有些数无法有限表示，只能模仿十进制进行四舍五入了，但是二进制只有 0 和 1 两个，于是变为 0 舍 1 入。这即是计算机中部分浮点数运算时出现误差，丢失精度的根本原因。大整数的精度丢失和浮点数本质上是一样的，尾数位最大是 52 位，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）。

- for in，for of 循环的区别

  1. for...in 循环：只能获得对象的键名，不能获得键值; for...of 循环：允许遍历获得键值

  2. 对于普通对象，没有部署原生的 iterator 接口，直接使用 for...of 会报错

  3. for...in 循环不仅遍历数字键名，还会遍历手动添加的其它键，甚至包括原型链上的键。for...of 则不会这样

  4. forEach 循环无法中途跳出，break 命令或 return 命令都不能奏效, for...of 循环可以与break、continue 和 return 配合使用，跳出循环

  5. 无论是 for...in 还是 for...of 都不能遍历出 Symbol 类型的值，遍历 Symbol 类型的值需要用 Object.getOwnPropertySymbols() 方法

  总之，for...in 循环主要是为了遍历对象而生，不适用于遍历数组，for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象

- 获取对象属性，通过点和[]的区别是什么

  1. 点操作符: 静态的。右侧必须是一个以属性名称命名的简单标识符。属性名用一个标识符来表示。标识符必须直接出现在js程序中，它们不是数据类型，因此程序无法修改它们。

  2. 中括号操作符: 动态的。方括号里必须是一个计算结果为字符串的表达式，属性名通过字符串表示。字符串是js的数据类型，在程序运行时可以修改和创建它们。

  区别：

  1. []中括号法：可以用变量作为属性名或访问，而点语法不可以;

  2. []中括号法：可以用数字作为属性名，而点语法不可以;

  3. []中括号法：可以动态访问的属性名，可以在程序运行时创建和修改属性，点操作符就不行；

  4. 如果属性名中包含会导致语法错误的字符，或者属性名是关键字或者保留字，也可以使用方括号表示法；

  5. 简单利用：在数组原型链上增加一个去重得的方法，并能实现链式写法。

- i++和++i的区别

  ++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的

- v-show 和 v-if 的区别

- 组件传参方式，vuex 的状态有哪些

- keep-alive 用法

- vue-router 两种模式有何区别

- vue2 和 vue3 区别

- vue 中 data 为什么定义为方法而不是对象

- vue.set()用在什么情况下，响应式监听缺陷是技术问题还是什么

- 跨域问题

- SEO 优化

- 性能优化问题，iconfont 和图片的区别，原理是什么

- webpack 配置有哪些

- 浏览器渲染机制，文件加载先后顺序

- 垃圾回收机制

- promise，setTimeout 和 setInterval 区别，setTimeout 设置一秒会在一秒后执行吗

- 小程序登录流程

- 移动端 1px 问题

- 谈谈对election的理解

- election 渲染进程和主进程关系，windows 对象和 web 的有什么区别

- 进程和线程区别

- 谈谈对微前端的理解

- 大文件上传如何处理

- http 请求有哪些，它们之间区别是什么
